# 개발일기
## 2022년 10월 25일 화요일 
### 오늘 배운 내용들
#### Fufure&then, async&await, 동기&비동기

#### Fufure&then

- Fufure란?

Future는 비동기 작업의 결과를 나타내며 미완료(value를 생성하기 전)또는 완료(value 생성)의 두 가지 상태를 가질 수 있습니다.

- 미완성
비동기 함수를 호출하면 완료되지 않은 미래가 반환됩니다. 미래에는 함수의 비동기 작업이 완료되거나 오류가 발생하기를 기다리고 있습니다.

- 완료
비동기 작업이 성공하면 미래는 값으로 완료됩니다. 그렇지 않으면 오류와 함께 완료됩니다.

- 값으로 완성
유형의 미래는 유형 Fufure값으로 완료됩니다 T. 예를 들어, 유형이 미래인 Fufure경우 문자열 값이 생성됩니다.
미래가 유횽한 가치를 창출하지 못하면 미래의 유형은 Fufure입니다

- 오류와 함께 완료
함수가 수행하는 비동기 작업이 어떤 이유로 든 실패 하면 미래는 오류와 함께 완료됩니다.

- Then란?

앞 실행이 완료 될 때 호출 할 콜백을 등록

#### async&await

- async&await란?

비동기 코드를 동기식으로 표현해서 간단하게 표현하기 위해 사용하는 async / await는 가장 최근에 나온 문법이다.
기존의 비동기 처리 방식인 콜백 함수와 프러미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성할 수 있게 도와준다.

-     async function 함수명() {
        await 비동기_처리_메서드_명();
      }
      
먼저 함수의 앞에 async라는 예약어를 붙인다. 그리고 나서 함수의 내부 로직 중 HTTP 통신을 하는 비동기 처리 코드 앞에 await를 붙인다.

일반적으로 await의 대상이 되는 비동기 처리 코드는 프로미스를 반환하는 API 호출 함수이다.(반드시 await가 의도한 대로 동작해야한다)

-     function fetchItems() {             (code)
        return new Promise(function(resolve, reject) {
          var items = [1,2,3];
          resolve(items)
        });
      }

      async function logItems() {
        var resultItems = await fetchItems();
        console.log(resultItems); // [1,2,3]
      }
      
fetchItems()함수는 프러미스 객체를 반환하는 함수이다.
fetchItems()함수를 실행하면 프러미스가 resolved되며 결과 값은
items배열이 된다.

logItmes()함수를 실행하면 fetchItems()함수의 결과값인 items배열이 resultItems 변수에 담긴다. 콘솔에는 [1, 2, 3]이 출력된다.

await를 사용하지 않았다면 데이터를 받아온 시점에 콘솔을 출력할 수 있도록 콜백함수나, .then() 등을 사용해야 했을 것이다.

#### 동기&비동기

- 동기란?

동기 방식은 서버에서 요청을 보냈을때 응답이 돌아아야 다음 동작을 수행할 수 있다. 즉 A작업이 모두 진행 될때까지 B작업은 대기해야한다.

-       '1st'
        '2nd'
        '3rd'
    
예상했던것 처럼 1st, 2nd, 3rd가 차례대로 찍히는 것을 알 수 있다. 

이처럼 코드가 위에서부터 아래로 내려오면서 하나가 끝나면 다음 코드가 실행되는 방식을 동기적 처리(Synchronous)라고한다.

- 비동기란?

비동기 방식은 반대로 요청을 보냈을 때 응답 상태와 상관없이 다음 동작을 수행할 수 있다. 
즉 A작업이 시작하면 동시에 B작업이 실행된다. A작업은 결과값이 나오는대로 출력된다.

-       console.log("1st");     (code)
        setTimeout(()=> {
          console.log("2nd");
        }, 0)
        console.log("3rd");
        
setTimeout() 메소드를 사용했다.
setTimeout() 메소드의 첫번째 인자는 콜백함수를 사용하였고, 두번째 인자는 지연시간이다.
두번째 인자가 0이기 때문에 바로 실행될거라 예상하고
1st, 2nd, 3rd가 찍힐것이라 예상하였다.

-       '1st'   (결과값)
        null
        '3rd'
        '2nd'
        
하지만 결과값은 1st, 3rd, 2nd가 찍혔다.
이는 setTimeout()메소드가 비동기적 API이기 때문이다.

비동기적 코드의 실행 결과는 동기적 코드가 전부 실행되고나서 값을 반환한다.        

참고 https://velog.io/@daybreak/동기-비동기-처리
